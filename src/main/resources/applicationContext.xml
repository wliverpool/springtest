<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xmlns:redis="http://www.springframework.org/schema/redis"
	xmlns:job="http://www.springframework.org/schema/batch" xmlns:util="http://www.springframework.org/schema/util"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:cache="http://www.springframework.org/schema/cache" xmlns:mongo="http://www.springframework.org/schema/data/mongo"
	xmlns:rdb="http://www.dangdang.com/schema/ddframe/rdb"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
	http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
	http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd
	http://www.springframework.org/schema/data/mongo http://www.springframework.org/schema/data/mongo/spring-mongo.xsd
	http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
	http://www.springframework.org/schema/redis http://www.springframework.org/schema/redis/spring-redis-1.0.xsd
	http://www.dangdang.com/schema/ddframe/rdb http://www.dangdang.com/schema/ddframe/rdb/rdb.xsd"
	default-lazy-init="true">

	<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<property name="ignoreUnresolvablePlaceholders" value="true"></property>
		<property name="locations"  value="classpath*:*.properties"></property>
	</bean>
	<!-- 加载完PropertySourcesPlaceholderConfigurer,可以直接使用${PATH}来获取所在系统的PATH环境变量 -->

	<!-- 国际化配置 -->
	<bean id="localeResolver"
		class="org.springframework.web.servlet.i18n.CookieLocaleResolver" />
	<bean id="messageSource"
		class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
		<property name="basenames">
			<list>
				<value>classpath:messages</value>
			</list>
		</property>
		<property name="useCodeAsDefaultMessage" value="true" />
		<property name="defaultEncoding" value="UTF-8" />
		<property name="cacheSeconds" value="60" />
	</bean>

	<mvc:default-servlet-handler />
	<!-- 扫描注解并注册验证器 -->
	<mvc:annotation-driven validator="myValidator">
		<mvc:message-converters register-defaults="true">
			<!-- JSON转换器 -->
			<bean id="mappingJacksonHttpMessageConverter"
				class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
				<property name="supportedMediaTypes">
					<list>
						<value>application/json;charset=UTF-8</value>
						<value>text/html;charset=UTF-8</value>
					</list>
				</property>
			</bean>
		</mvc:message-converters>
	</mvc:annotation-driven>
	
	<!-- springmvc 拦截器 -->
	<mvc:interceptors>  
		<mvc:interceptor>  
		    <mvc:mapping path="/**" />  
		    <bean class="com.interceptor.TokenInterceptor" />  
		</mvc:interceptor> 
	</mvc:interceptors> 
	
	<!-- 缓存配置 -->
	<cache:annotation-driven />

	<bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"
		p:cache-manager-ref="ehcacheManager" />

	<bean id="ehcacheManager"
		class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"
		p:configLocation="classpath:/ehcache.xml" />

	<context:component-scan base-package="com" />


	<!-- 自定义文件上传转换器 -->
	<bean id="multipartResolver" class="com.action.CustomMultipartResolver">
		<property name="defaultEncoding" value="utf-8" />
		<property name="maxUploadSize" value="10485760000" />
		<property name="maxInMemorySize" value="40960" />
	</bean>
	<!--bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> 
		<property name="defaultEncoding" value="utf-8"/> <property name="maxUploadSize" 
		value="10485760000"/> <property name="maxInMemorySize" value="40960"/> </bean -->

	<!-- 异常处理器 -->
	<bean id="exceptionResolver"
		class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
		<!-- 定义默认的异常处理页面，当该异常类型的注册时使用 -->  
    	<property name="defaultErrorView" value="error"></property>  
    	<!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --> 
		<property name="exceptionMappings">
			<props>
				<prop key="java.lang.Exception">exception</prop>
			</props>
		</property>
	</bean>

	<!-- 配置验证器 -->
	<bean
		class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"
		id="myValidator">
		<property name="providerClass" value="org.hibernate.validator.HibernateValidator"></property>
		<property name="validationMessageSource" ref="messageSource"></property>
	</bean>

	<bean id="defaultAnnotationHandlerMapping"
		class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping" />

	<bean id="annotationMethodHandlerAdapter"
		class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" />

	<!-- org.springframework.web.servlet.view.ResourceBundleViewResolver 用于多个视图集成时,ResourceBundleViewResolver是通过解析资源文件来解析请求输出文件的。 
		<property name="basename" value="views"></property>,即表示在/WEB-INF/classes路径下有一个 
		views.properties文件,本例中views.properties的内容为 welcome.(class)=org.springframework.web.servlet.view.velocity.VelocityView 
		welcome.url=welcome.vm freemarker.(class)=org.springframework.web.servlet.view.freemarker.FreeMarkerView 
		freemarker.url=freemarker.ftl -->
	<bean class="org.springframework.web.servlet.view.ResourceBundleViewResolver">
		<property name="basename" value="views"></property>
		<!-- <property name="order" value="0"></property> -->
	</bean>

	<!-- velocity视图解析器 -->
	<!-- <bean id="velocityViewResolver" class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"> 
		<property name="cache" value="true"/> <property name="prefix" value="/"/> 
		<property name="suffix" value=".vm"/> </bean> -->
	<bean id="velocityViewResolver"
		class="org.springframework.web.servlet.view.velocity.VelocityLayoutViewResolver">
		<property name="cache" value="true" />
		<property name="exposeSpringMacroHelpers" value="true" />
		<!-- 在velocity中可以使用request和session -->
		<property name="requestContextAttribute" value="true" />
		<property name="exposeSessionAttributes" value="true" />
		<property name="prefix" value="/"></property>
		<property name="suffix" value=".vm" />
		<property name="order" value="1"></property>
		<property name="allowSessionOverride" value="true"></property>
		<!-- property name="viewNames"> <list> <value>*.vm</value> <value>*.htm</value> 
			</list> </property> -->
		<property name="contentType" value="text/html; charset=UTF-8"></property>
		<property name="toolboxConfigLocation" value="/WEB-INF/velocity-toolbox.xml"></property>
		<property name="viewClass"
			value="org.springframework.web.servlet.view.velocity.VelocityLayoutView" />
		<property name="layoutUrl" value="layout/layout.vm" />
	</bean>

	<!-- velocity环境配置 -->
	<bean id="velocityConfig"
		class="org.springframework.web.servlet.view.velocity.VelocityConfigurer">
		<!-- velocity配置文件路径 -->
		<property name="configLocation" value="/WEB-INF/velocity.properties" />
		<!-- velocity模板路径 -->
		<property name="resourceLoaderPath" value="/WEB-INF/velocity/" />
		<property name="velocityProperties">
			<props>
				<prop key="input.encoding">UTF-8</prop>
				<prop key="output.encoding">UTF-8</prop>
				<prop key="parser.pool.size">100</prop>
				<prop key="velocimacro.library">macro/macro.vm</prop>
			</props>
		</property>
	</bean>

	<!-- jsp视图解析器 -->
	<bean id="viewResolver"
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/" />
		<property name="suffix" value=".jsp" />
		<property name="viewClass"
			value="org.springframework.web.servlet.view.JstlView" />
	</bean>



	<!-- 分布式数据库事务开始 -->
	<!-- Atomikos多数据源 -->
	<bean id="secondDatabase" class="com.atomikos.jdbc.AtomikosDataSourceBean"
		init-method="init" destroy-method="close">
		<property name="uniqueResourceName" value="mysql/b" />
		<property name="xaDataSourceClassName"
			value="com.mysql.jdbc.jdbc2.optional.MysqlXADataSource" />
		<property name="xaProperties">
			<props>
				<prop key="user">root</prop>
				<prop key="password">wfmhbbwt</prop>
				<prop key="URL">jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8
				</prop>
			</props>
		</property>
		<property name="poolSize" value="10" />
		<property name="reapTimeout" value="20000" />
		<property name="maxLifetime" value="100" />
	</bean>

	<bean id="firstDatabase" class="com.atomikos.jdbc.AtomikosDataSourceBean"
		init-method="init" destroy-method="close">
		<property name="uniqueResourceName" value="mysql/a" />
		<property name="xaDataSourceClassName"
			value="com.mysql.jdbc.jdbc2.optional.MysqlXADataSource" />
		<property name="xaProperties">
			<props>
				<prop key="user">root</prop>
				<prop key="password">wfmhbbwt</prop>
				<prop key="URL">jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8
				</prop>
			</props>
		</property>
		<property name="poolSize" value="10" />
		<property name="reapTimeout" value="20000" />
		<property name="maxLifetime" value="100" />
	</bean>
	<!-- atomikos事务管理 -->
	<bean id="atomikosUserTransactionManager" class="com.atomikos.icatch.jta.UserTransactionManager">
		<description>atomikosUserTransactionManager</description>
		<property name="forceShutdown" value="true" />
	</bean>

	<bean id="atomikosUserTransaction" class="com.atomikos.icatch.jta.UserTransactionImp">
		<property name="transactionTimeout" value="300" />
	</bean>

	<bean id="atomikosSpringTransactionManager"
		class="org.springframework.transaction.jta.JtaTransactionManager">
		<property name="transactionManager" ref="atomikosUserTransactionManager" />
		<property name="userTransaction" ref="atomikosUserTransaction" />
		<!-- 必须设置，否则程序出现异常 JtaTransactionManager does not support custom isolation 
			levels by default -->
		<property name="allowCustomIsolationLevels" value="true" />
	</bean>

	<bean id="jdbcTemplateA" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="firstDatabase" />
	</bean>

	<bean id="jdbcTemplateB" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="secondDatabase" />
	</bean>

	<bean id="liveWarmDao" class="com.dao.atomikos.LiveWarmDao">
		<property name="jdbcTemplate" ref="jdbcTemplateB" />
	</bean>

	<bean id="tmpUserDao" class="com.dao.atomikos.TmpUserDao">
		<property name="jdbcTemplate" ref="jdbcTemplateA" />
	</bean>

	<tx:advice id="atomikosTxAdvice" transaction-manager="atomikosSpringTransactionManager">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED" />
			<tx:method name="get*" read-only="true" />
		</tx:attributes>
	</tx:advice>

	<aop:aspectj-autoproxy />

	<aop:config proxy-target-class="true">
		<aop:pointcut expression="execution (* com.service.atomikos.*.*(..))"
			id="services" />
		<aop:advisor advice-ref="atomikosTxAdvice" pointcut-ref="services" />
	</aop:config>

	<bean id="atomikosService" class="com.service.atomikos.AtomikosService">
		<property name="tmpUserDao" ref="tmpUserDao" />
		<property name="liveWarmDao" ref="liveWarmDao" />
	</bean>
	<!-- 分布式数据库事务结束 -->

	<!-- 读写分离开始 -->
	<!-- 测试读写分离数据源,写数据源 -->
	<bean id="masterdataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url"
			value="jdbc:mysql://localhost:3306/test1?characterEncoding=UTF-8&amp;useUnicode=true" />
		<property name="username" value="root" />
		<property name="password" value="wfmhbbwt" />
	</bean>

	<!-- 测试读写分离数据源,读数据源 -->
	<bean id="slavedataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url"
			value="jdbc:mysql://localhost:3306/test2?characterEncoding=UTF-8&amp;useUnicode=true" />
		<property name="username" value="root" />
		<property name="password" value="wfmhbbwt" />
	</bean>

	<bean id="dataSource" class="com.dao.util.DynamicDataSource">
		<property name="targetDataSources">
			<map key-type="java.lang.String">
				<!-- write -->
				<entry key="master" value-ref="masterdataSource" />
				<!-- read -->
				<entry key="slave" value-ref="slavedataSource" />
			</map>
		</property>
		<property name="defaultTargetDataSource" ref="masterdataSource" />
	</bean>

	<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="userFileDao" class="com.dao.UserFileDao">
		<property name="jdbcTemplate" ref="jdbcTemplate" />
	</bean>

	<bean id="LiverpoolDao" class="com.dao.LiverpoolDao">
		<property name="jdbcTemplate" ref="jdbcTemplate" />
	</bean>

	<bean id="LiverpoolService" class="com.service.LiverpoolService">
		<property name="lfcDao" ref="LiverpoolDao" />
	</bean>
	<!-- 读写分离结束 -->

	<!-- 试用gridManager开始 -->
	<bean id="qaReaderDao" class="com.dao.QaReaderDao">
		<property name="jdbcTemplate" ref="jdbcTemplate" />
	</bean>

	<bean id="qaReaderService" class="com.service.QaReaderService">
		<property name="qaReaderDao" ref="qaReaderDao" />
	</bean>
	<!-- 试用gridManager结束 -->

	<!-- 系统监控 -->
	<bean id="monitorService" class="com.service.MonitorServiceImpl" />

	<!-- shiro -->
	<bean id="userDao" class="com.dao.UserDaoImpl">
		<property name="jdbcTemplate" ref="jdbcTemplate" />
	</bean>

	<bean id="roleDao" class="com.dao.RoleDaoImpl" />

	<bean id="permissionDao" class="com.dao.PermissionDaoImpl">
		<property name="jdbcTemplate" ref="jdbcTemplate" />
	</bean>

	<bean id="userService" class="com.service.UserServiceImpl">
		<property name="userDao" ref="userDao" />
	</bean>

	<!-- redis连接配置 -->
	<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">
		<property name="maxTotal" value="200" />
		<property name="maxIdle" value="200" />
		<property name="maxWaitMillis" value="0" />
		<property name="testOnBorrow" value="true" />
	</bean>

	<bean id="jedisCluster" class="com.util.JedisClusterFactory">
		<property name="addressConfig">
			<value>classpath:redis-cluster.properties</value>
		</property>
		<property name="addressKeyPrefix" value="address" />
		<property name="timeout" value="30000" />
		<property name="maxRedirections" value="6" />
		<property name="genericObjectPoolConfig" ref="jedisPoolConfig" />
	</bean>
	<!-- spring redis 主从 -->
	<bean id="jedisConnectionFactory"
		class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory">
		<property name="hostName" value="127.0.0.1" />
		<property name="port" value="6379" />
		<property name="password" value="liverpool" />
		<property name="poolConfig" ref="jedisPoolConfig" />
	</bean>
	
	<!-- spring redis配置Cluster -->
	<!--bean id="redisClusterConfiguration"
		class="org.springframework.data.redis.connection.RedisClusterConfiguration">
		<property name="maxRedirects" value="3"></property>
		<property name="clusterNodes">
			<set>
				<bean class="org.springframework.data.redis.connection.RedisClusterNode">
					<constructor-arg name="host" value="172.16.48.129"></constructor-arg>
					<constructor-arg name="port" value="7000"></constructor-arg>
				</bean>
				<bean class="org.springframework.data.redis.connection.RedisClusterNode">
					<constructor-arg name="host" value="172.16.48.129"></constructor-arg>
					<constructor-arg name="port" value="7001"></constructor-arg>
				</bean>
				<bean class="org.springframework.data.redis.connection.RedisClusterNode">
					<constructor-arg name="host" value="172.16.48.129"></constructor-arg>
					<constructor-arg name="port" value="7002"></constructor-arg>
				</bean>
				<bean class="org.springframework.data.redis.connection.RedisClusterNode">
					<constructor-arg name="host" value="172.16.48.129"></constructor-arg>
					<constructor-arg name="port" value="7003"></constructor-arg>
				</bean>
				<bean class="org.springframework.data.redis.connection.RedisClusterNode">
					<constructor-arg name="host" value="172.16.48.129"></constructor-arg>
					<constructor-arg name="port" value="7004"></constructor-arg>
				</bean>
				<bean class="org.springframework.data.redis.connection.RedisClusterNode">
					<constructor-arg name="host" value="172.16.48.129"></constructor-arg>
					<constructor-arg name="port" value="7005"></constructor-arg>
				</bean>
			</set>
		</property>
	</bean>
	
	<bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory">
		<constructor-arg ref="redisClusterConfiguration" />
		<constructor-arg ref="jedisPoolConfig" />
		<property name="password" value="liverpool"></property>
	</bean-->

	<bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate">
		<property name="connectionFactory" ref="jedisConnectionFactory" />
		<!-- 这个是对key的默认序列化器。默认值是StringSerializer -->
		<property name="keySerializer">
			<bean
				class="org.springframework.data.redis.serializer.StringRedisSerializer" />
		</property>
		<!-- 这个是对value的默认序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer -->
		<property name="valueSerializer">
			<bean
				class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" />
		</property>
		<!-- 对hash结构数据的hashkey序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer -->
		<property name="hashKeySerializer">
			<bean
				class="org.springframework.data.redis.serializer.StringRedisSerializer" />
		</property>
		<!-- 对hash结构数据的hashvalue序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer -->
		<property name="hashValueSerializer">
			<bean
				class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" />
		</property>
		<!-- 也可以通过transcational注解控制 -->
		<property name="enableTransactionSupport" value="false" />
	</bean>  

	<bean id="redisDao" class="com.dao.redis.RedisDao">
		<property name="stringTemplate" ref="redisStringTemplate"></property>
		<property name="updateAvailableSavingsCard" ref="updateAvailable"></property>
		<property name="template" ref="redisTemplate"></property>
	</bean>

	<bean id="redisStringTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"
		p:connection-factory-ref="jedisConnectionFactory" />

	<bean id="redisMessageBroadcast" class="com.service.RedisMessageBroadcast">  
        <property name="template" ref="redisStringTemplate"/>  
    </bean>

	<bean id="redisMsgListener" class="com.service.RedisMessageListener">  
        <property name="template" ref="redisStringTemplate"/>  
    </bean>
    
    <redis:listener-container connection-factory="jedisConnectionFactory">
		<!-- the method attribute can be skipped as the default method name is 
			"handleMessage" -->
			<!-- topic代表监听的通道，是一个正规匹配 -->
		<redis:listener ref="redisMsgListener" method="handleMessage" topic="*" />
	</redis:listener-container>

	<bean id="updateAvailable"
		class="org.springframework.data.redis.core.script.DefaultRedisScript">
		<property name="location" value="classpath:lua/updateAvailable.lua" />
		<property name="resultType" value="java.lang.String" />
	</bean>

	<!-- spring mybatis -->
	<bean id="mybatisDataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName">
			<value>org.gjt.mm.mysql.Driver</value>
		</property>
		<property name="url">
			<value>jdbc:mysql://localhost:3306/world?useUnicode=true&amp;characterEncoding=UTF-8
			</value>
			<!--springmybaitis是我的数据库 -->
		</property>
		<property name="username">
			<value>root</value>
		</property>
		<property name="password">
			<value>wfmhbbwt</value>
		</property>
	</bean>
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="mybatisDataSource" />
		<property name="configLocation" value="classpath:spring-mybatis.xml"></property>
	</bean>
	<bean id="mybatisTx"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="mybatisDataSource" />
	</bean>
	<!-- mybatis编程式事务模板 -->
	<bean id="myBatisTTemplate"
		class="org.springframework.transaction.support.TransactionTemplate">
		<property name="transactionManager" ref="mybatisTx"></property>
	</bean>
	<tx:advice id="mybatisTxAdvice" transaction-manager="mybatisTx">
		<tx:attributes>
			<tx:method name="save*" propagation="REQUIRED" />
			<tx:method name="get*" read-only="true" />
			<tx:method name="tradeOut*" propagation="NEVER" />
		</tx:attributes>
	</tx:advice>
	<aop:config proxy-target-class="true">
		<aop:pointcut expression="execution (* com.service.mybatis.*.*(..))"
			id="mybatisServices" />
		<aop:advisor advice-ref="mybatisTxAdvice" pointcut-ref="mybatisServices" />
	</aop:config>
	<bean id="cityDao" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.CityMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="orderInfoDao" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.OrderInfoMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="clobMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.MybatisClobMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="personMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.PersonMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="bookBrowserMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.BookBrowserMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="orderApplyDao" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.OrderApplyMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="cityService" class="com.service.mybatis.CityService">
		<property name="cityMapper" ref="cityDao"></property>
	</bean>
	<bean id="orderService" class="com.service.mybatis.OrderService">
		<property name="orderInfoMapper" ref="orderInfoDao"></property>
		<property name="orderApplyMapper" ref="orderApplyDao"></property>
		<property name="ptm" ref="mybatisTx"></property>
		<property name="transactionTemplate" ref="myBatisTTemplate"></property>
	</bean>
	<bean id="seckillMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.SeckillMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="successkilledMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
		<property name="mapperInterface" value="com.dao.mybatisauto.SuccessKilledMapper"></property>
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
	</bean>
	<bean id="secKillService" class="com.service.mybatis.SecKillService">
		<property name="successKilledMapper" ref="successkilledMapper"></property>
		<property name="seckillMapper" ref="seckillMapper"></property>
		<property name="redisDao" ref="redisDao"></property>
	</bean>

	<!-- spring mongodb -->
	<!-- 配置mongo参数 ,产生的bean的id默认为mongo 主从mongodb的配置host="172.16.48.128" port="27017" 
		credentials="root:wfmhbbwt@liverpool" -->
	<!-- mongo:mongo-client id="mongo" replica-set="172.16.48.128:40000" credentials="root:wfmhbbwt@liverpool" >
		<mongo:client-options connections-per-host="10"
			read-preference="SECONDARY_PREFERRED"
			threads-allowed-to-block-for-connection-multiplier="4"
			connect-timeout="1500" max-wait-time="1500" socket-timeout="1500"
			socket-keep-alive="true" write-concern="SAFE" />
	</mongo:mongo-client-->

	<!-- 配置mongofactory ,产生的bean的id默认为mongoDbFactory -->
	<!-- mongo:db-factory id="mongoDbFactory" dbname="liverpool"
		mongo-ref="mongo" />

	<bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
		<constructor-arg name="mongoDbFactory" ref="mongoDbFactory" />
	</bean>

	<bean id="personRepository" class="com.dao.mongodb.PersonReposity">
		<property name="template" ref="mongoTemplate" />
	</bean>

	<bean id="batchUpdate" class="com.dao.mongodb.BatchUpdateUtil">
		<property name="template" ref="mongoTemplate" />
	</bean-->

	<context:annotation-config />

	<bean id="cacheService" class="com.service.CacheService" />

	<bean id="queryService" class="com.service.QueryService">
		<property name="cacheService" ref="cacheService" />
	</bean>

	<!-- spring batch -->
	<!-- 每个Batch都会包含一个Job。Job就像一个容器，这个容器里装了若干Step，例如读取数据，处理数据，然后将这些数据存储起来 (ItemReader用来读取数据，ItemProcessor用来处理数据，ItemWriter用来写数据) 
		。 JobLauncher用来启动Job，JobRepository是上述处理提供的一种持久化机制，它为JobLauncher，Job，和Step实例提供CRUD操作。 
		从DB或是文件中取出数据的时候，read()操作每次只读取一条记录，之后将读取的这条数据传递给processor(item)处理，框架将重复做这两步操作， 
		直到读取记录的件数达到batch配置信息中”commin-interval”设定值的时候，就会调用一次write操作。然后再重复上图的处理，直到处理完所有的数据。 
		当这个Step的工作完成以后，或是跳到其他Step，或是结束处理。 -->
	<bean id="jobLauncher"
		class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
		<property name="jobRepository" ref="jobRepository" />
	</bean>

	<!-- Persist batch metadata in-memory -->
	<bean id="jobRepository"
		class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
		<property name="transactionManager" ref="jobTransactionManager" />
	</bean>
	
	<!-- Persist batch metadata in database -->
    <!-- bean id="jobRepository" class="org.springframework.batch.core.repository.support.JobRepositoryFactoryBean">
        <property name="transactionManager" ref="transactionManager"/>
        <property name="databaseType" value="MySQL"/>
        <property name="dataSource" ref="dataSource"/>
    </bean-->

	<bean id="jobTransactionManager"
		class="org.springframework.batch.support.transaction.ResourcelessTransactionManager">
	</bean>

	<!-- 配置了一个ID为helloWorldJob的job，此job有两个Step ： step_hello和step_world， 前者负责输出“Hello 
		”，后者负责输出“World!”，当第一个Step完成以后，执行第二个Step。 -->
	<job:job id="helloWorldJob">
		<job:step id="step_hello" next="step_world">
			<job:tasklet ref="hello" transaction-manager="jobTransactionManager"></job:tasklet>
		</job:step>
		<job:step id="step_world">
			<job:tasklet ref="world" transaction-manager="jobTransactionManager"></job:tasklet>
		</job:step>
	</job:job>

	<bean id="hello" class="com.job.WriteTasklet">
		<property name="message" value="Hello "></property>
	</bean>

	<bean id="world" class="com.job.WriteTasklet">
		<property name="message" value=" World!"></property>
	</bean>
	
	<!-- 带参数job,以及springbatch整合mybatis -->
	<job:job id="useJobParam" incrementer="">
		<job:validator ref="jobParametersValidator"></job:validator>
		<job:step id="jobParam1">
			<job:tasklet transaction-manager="jobTransactionManager">
				<job:chunk reader="mybatisReader" writer="mybatisWriter" commit-interval="1"></job:chunk>
				<!-- 监听器 -->
				<job:listeners>
					<job:listener ref="chunkListener"></job:listener>
					<job:listener ref="itemReadListener"></job:listener>
				</job:listeners>
			</job:tasklet>
			<job:listeners>
				<job:listener ref="stepExecutionListener"></job:listener>
			</job:listeners>
		</job:step>
	</job:job>
	
	<bean id="jobParametersValidator" class="org.springframework.batch.core.job.DefaultJobParametersValidator">        
	    <property name="requiredKeys">        
	        <set>    
	            <value>paramId</value>
	        </set>    
	    </property>        
	    <property name="optionalKeys">        
	        <set>    
	            <value>idMax</value>
	        </set>    
	    </property>        
	</bean>  
	
	<!-- 通过mybatis读取数据 -->
	<bean id="mybatisReader" class="org.mybatis.spring.batch.MyBatisPagingItemReader" scope="step">
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
		<property name="pageSize" value="5"></property>
		<property name="queryId" value="com.dao.mybatisauto.MybatisClobMapper.selectPagingWhere"></property>
		<property name="parameterValues">
			<map>
				<!-- job级参数处理 -->
				<entry key="id" value="#{jobParameters['paramId']}"></entry>
				<entry key="idMax" value="#{jobParameters['idMax']}"></entry>
			</map>
		</property>
	</bean>
	
	<bean id="mybatisWriter" class="org.mybatis.spring.batch.MyBatisBatchItemWriter" scope="prototype">
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
		<property name="statementId" value="com.dao.mybatisauto.MybatisClobMapper.insertClobTest"></property>
	</bean>

	<!-- 操作csv文件的job -->
	<job:job id="csvJob">
		<job:step id="csvStep">
			<job:tasklet transaction-manager="jobTransactionManager">
				<!-- csv的数据处理过程processor是由自己写的java定义的并通过@Component注解进行标注 -->
				<job:chunk reader="csvItemReader" writer="csvItemWriter"
					processor="csvItemProcessor" commit-interval="1" skip-limit="1">
					<!-- 发生指定异常时job不结束,而是跳过当前记录,skip-limit指定跳过几条 -->
					<job:skippable-exception-classes>
						<!-- 允许跳过的异常 -->
                    	<job:include class="org.springframework.batch.item.file.FlatFileParseException" />
                    	<!-- 不允许跳过的异常 -->
                    	<job:exclude class="java.io.FileNotFoundException"/>
                    </job:skippable-exception-classes>
				</job:chunk>
			</job:tasklet>
		</job:step>
	</job:job>

	<!-- 读取csv文件 csvItemReader实现的是Spring Batch提供FlatFileItemReader类，此类主要用于Flat文件的读操作。它包含两个必要的属性 
		resource和 lineMapper。 前者指定要读取的文件的位置，后者是将文件的每一行映射成一个Pojo对象。其中 lineMapper也有两个重要属性 
		lineTokenizer和 fieldSetMapper， lineTokenizer将文件的一行分解成一个 FieldSet，然后由 fieldSetMapper映射成Pojo对象。 
		这种方式与DB的读操作非常类似。lineMapper类似于ResultSet，文件中的一行类似于Table中的一条记录，被封装成的FieldSet，类似于RowMapper。 
		至于怎么将一条记录封装，这个工作由lineTokenizer的继承类DelimitedLineTokenizer完成。DelimitedLineTokenizer的delimiter属性决定文件的一行数据按照什么分解，默认的是“，”， 
		names属性标示分解的每个字段的名字，传给fieldSetMapper（本实例用的是BeanWrapperFieldSetMapper）的时候，就可以按照这个名字取得相应的值。 
		fieldSetMapper的属性prototypeBeanName，是映射Pojo类的名字。设置了此属性后，框架就会将lineTokenizer分解成的一个FieldSet映射成Pojo对象， 
		映射是按照名字来完成的(lineTokenizer分解时标注的名字与Pojo对象中字段的名字对应)。 总之，FlatFileItemReader读取一条记录由以下四步完成：1，从resource指定的文件中读取一条记录；2，lineTokenizer将这条记录按照delimiter分解成Fileset， 
		每个字段的名字由names属性取得；3，将分解成的Fileset传递给fieldSetMapper，由其按照名字映射成Pojo对象；4，最终由FlatFileItemReader将映射成的Pojo对象返回， 
		框架将返回的对象传递给Processor。 -->
	<bean id="csvItemReader" class="org.springframework.batch.item.file.FlatFileItemReader"
		scope="step">
		<property name="resource" value="classpath:inputFile.csv" />
		<property name="lineMapper">
			<bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
				<property name="lineTokenizer" ref="lineTokenizer" />
				<property name="fieldSetMapper">
					<bean
						class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
						<!-- 指定转换的pojo -->
						<property name="prototypeBeanName" value="student"></property>
					</bean>
				</property>
			</bean>
		</property>
	</bean>

	<bean id="student" class="com.pojo.Student"></bean>

	<!-- lineTokenizer处理csv格式 -->
	<bean id="lineTokenizer"
		class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
		<property name="delimiter" value="," />
		<property name="names">
			<list>
				<value>ID</value>
				<value>name</value>
				<value>age</value>
				<value>score</value>
			</list>
		</property>
	</bean>

	<!-- 写CSV文件 csvItemWriter实现的是FlatFileItemWriter类。此类与FlatFileItemReader类相似，也有两个重要的属性：resource和lineAggregator。 
		前者是要输出的文件的路径，后者和lineTokenizer类似。lineAggregator(本实例用DelimitedLineAggregator类)也有两个重要的属性：delimiter和fieldExtractor。 
		Delimiter标示输出的字段以什么分割，后者将Pojo对象组装成由Pojo对象的字段组成的一个字符串。同样FlatFileItemWriter写一条记录也有以下四步完成： 
		1，Processor传递过来一个对象给lineAggregator； 2，lineAggregator将其这个对象转化成一个数组； 3，再由lineAggregator的属性fieldExtractor将数组转化成按照delimiter分割一个字符串； 
		4，将这个字符串输出。 -->
	<bean id="csvItemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter"
		scope="step">
		<property name="resource" value="file:src/outputFile.csv" />
		<property name="lineAggregator">
			<bean
				class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
				<property name="delimiter" value=","></property>
				<property name="fieldExtractor">
					<bean
						class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
						<property name="names" value="name,age,score"></property>
					</bean>
				</property>
			</bean>
		</property>
	</bean>

	<!-- xml处理的job -->
	<job:job id="xmlFileReadAndWriterJob">
		<job:step id="xmlFileReadAndWriterStep">
			<job:tasklet>
				<!-- xml的数据处理过程processor是由自己写的java定义的并通过@Component注解进行标注 -->
				<job:chunk reader="xmlReader" writer="xmlWriter"
					processor="xmlProcessor" commit-interval="10">
				</job:chunk>
			</job:tasklet>
		</job:step>
	</job:job>

	<!-- XML文件读取 -->
	<bean id="xmlReader" class="org.springframework.batch.item.xml.StaxEventItemReader"
		scope="step">
		<!-- 指定根节点 -->
		<property name="fragmentRootElementName" value="goods" />
		<!-- 解析节点信息，并映射成pojo对象 -->
		<property name="unmarshaller" ref="tradeMarshaller" />
		<!-- 根据job的inputFilePath参数获取xml的位置 -->
		<property name="resource" value="file:#{jobParameters['inputFilePath']}"></property>
	</bean>

	<!-- XML文件写入 -->
	<bean id="xmlWriter" class="org.springframework.batch.item.xml.StaxEventItemWriter"
		scope="step">
		<property name="rootTagName" value="wanggc" />
		<property name="marshaller" ref="tradeMarshaller" />
		<property name="resource" value="file:#{jobParameters['outputFilePath']}" />
	</bean>

	<bean id="tradeMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
		<property name="aliases">
			<util:map id="aliases">
				<entry key="goods" value="com.pojo.Goods" />
				<entry key="buyDay" value="java.util.Date"></entry>
			</util:map>
		</property>
	</bean>

	<!-- 列数固定文件读取Job -->
	<job:job id="fixedLengthJob">
		<job:step id="fixedLengthStep">
			<job:tasklet>
				<!-- 数据处理过程processor是由自己写的java定义的并通过@Component注解进行标注 -->
				<job:chunk reader="fixedLengthReader" writer="fixedLengthWriter"
					processor="fixedLengthProcessor" commit-interval="10">
				</job:chunk>
			</job:tasklet>
		</job:step>
	</job:job>

	<!-- 固定长文件的读信息的配置 -->
	<bean id="fixedLengthReader" class="org.springframework.batch.item.file.FlatFileItemReader"
		scope="step">
		<property name="resource" value="file:#{jobParameters['inputFilePath']}" />
		<property name="lineMapper">
			<bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
				<property name="lineTokenizer" ref="filelineTokenizer" />
				<property name="fieldSetMapper">
					<bean
						class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
						<property name="prototypeBeanName" value="studentBean" />
					</bean>
				</property>
			</bean>
		</property>
	</bean>

	<bean id="studentBean" class="com.pojo.StudentPojo" scope="prototype" />

	<bean id="filelineTokenizer"
		class="org.springframework.batch.item.file.transform.FixedLengthTokenizer">
		<!-- 配置文件列与属性对应 -->
		<property name="columns" value="1-6,7-15,16-18,19-" />
		<property name="names" value="ID,name,age,score" />
	</bean>

	<!-- 固定长格式文件的写 -->
	<bean id="fixedLengthWriter" class="org.springframework.batch.item.file.FlatFileItemWriter"
		scope="step">
		<property name="resource" value="file:#{jobParameters['outputFilePath']}" />
		<property name="lineAggregator">
			<bean
				class="org.springframework.batch.item.file.transform.FormatterLineAggregator">
				<property name="fieldExtractor">
					<bean
						class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
						<property name="names" value="ID,name,age,score" />
					</bean>
				</property>
				<!-- pojo每个属性所占的长度和格式 -->
				<property name="format" value="%-9s%-20s%3d%-2.0f" />
			</bean>
		</property>
	</bean>
	
	<!-- jdbc数据转换 -->
	<job:job id="jdbcjob">
		<job:step id="jdbcStep">
			<job:tasklet>
				<!-- 数据处理过程processor是由自己写的java定义的并通过@Component注解进行标注 -->
				<job:chunk reader="jdbcItemReader" writer="jdbcItemWriter"
					processor="jdbcProcessor" commit-interval="5">
				</job:chunk>
			</job:tasklet>
		</job:step>
	</job:job>

	<!-- 从数据库获取数据 -->
	<bean id="jdbcItemReader"
		class="org.springframework.batch.item.database.JdbcCursorItemReader"
		scope="step">
		<!-- 读取的数据源 -->
		<property name="dataSource" ref="mybatisDataSource" />
		<!-- 读取数据的sql -->
		<property name="sql"
			value="select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id &lt; ?" />
		<property name="rowMapper">
			<bean class="org.springframework.jdbc.core.BeanPropertyRowMapper">
			<!-- 映射的pojo类型 -->
				<property name="mappedClass"
					value="com.pojo.Seckill" />
			</bean>
		</property>
		<property name="preparedStatementSetter" ref="paramStatementSetter" />
	</bean>
	
	<!-- 读取数据时的参数 -->
	<bean id="paramStatementSetter"
		class="org.springframework.batch.core.resource.ListPreparedStatementSetter"
		scope="step">
		<property name="parameters">
			<list>
				<value>#{jobParameters['id']}</value>
			</list>
		</property>
	</bean>

	<bean id="jdbcItemWriter"
		class="org.springframework.batch.item.database.JdbcBatchItemWriter">
		<!-- 写入的数据源 -->
		<property name="dataSource" ref="mybatisDataSource" />
		<!-- 写入表的insert sql -->
		<property name="sql"
			value="insert into TargetSeckill (id,name,number,started,ended,created)
                   values
                  (:id,:name,:number,:started,:ended,:created)" />
		<property name="itemSqlParameterSourceProvider">
			<bean
				class="org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider" />
		</property>
	</bean>

	<!-- zookeeper -->
	<bean id="zkSerializer" class="com.util.ZkUtils.StringSerializer">
		<constructor-arg value="UTF-8" />
	</bean>

	<bean id="zkClient" class="org.I0Itec.zkclient.ZkClient">
		<constructor-arg index="0" value="172.16.48.135:4180,172.16.48.135:4181,172.16.48.135:4182" />
		<constructor-arg index="1" value="100000" />
		<property name="zkSerializer" ref="zkSerializer"></property>
	</bean>
	
	<!-- zookeeper配置信息修改监听器 -->
	<bean id="configChangeSubscriber" class="com.util.ZkConfigChangeSubscriberImpl">
		<constructor-arg ref="zkClient"></constructor-arg>
		<constructor-arg value="/llyg/conf"></constructor-arg>
	</bean>
	<!-- 配置文件加载工厂，从zookeeper加载配置并实现监听配置信息修改 -->
	<bean id="helperFactory" class="com.util.DynamicPropertiesHelperFactory">
		<constructor-arg ref="configChangeSubscriber"></constructor-arg>
	</bean>
	<!-- 利用zookeeper分布式锁简单实现 -->
	<bean id="baseDistributedLock" class="com.lock.BaseDistributedLock">
		<constructor-arg ref="zkClient"></constructor-arg>
		<constructor-arg value="/llyg"></constructor-arg>
		<constructor-arg value="lock"></constructor-arg>
	</bean>
	
	<bean id="simpleDistributedLock" class="com.lock.SimpleDistributedLock">
		<property name="baseDistributedLock" ref="baseDistributedLock"></property>
	</bean>
	
	<!-- 调用dubbo的服务 -->
	<!-- dubbo:application name="dubbo_consumer"></dubbo:application-->
   	<!-- 使用zookeeper注册中心暴露服务地址 -->  
   	<!-- dubbo:registry protocol="zookeeper" address="172.16.48.138:4181,172.16.48.138:4180,172.16.48.138:4182" check="false"></dubbo:registry--> 
    <!-- 要引用的服务 -->  
    <!-- dubbo:reference 的一些属性的说明：
      1）interface调用的服务接口
      2）check 启动时检查提供者是否存在，true报错，false忽略
      3）registry 从指定注册中心注册获取服务列表，在多个注册中心时使用，值为<dubbo:registry>的id属性，多个注册中心ID用逗号分隔
      4）loadbalance 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮循，最少活跃调用 -->
   	<!-- dubbo:reference interface="wfm.dubboserver.service.TestService" id="testServiceImpl"/>
	<dubbo:reference id="genericService" interface="com.alibaba.dubbo.rpc.service.GenericService" generic="true" /-->

	<!-- 自动生产接口api配置 -->
	<!-- bean class="com.util.SwaggerConfig" id="swagger2Config"/>
	<mvc:resources location="classpath:/META-INF/resources/" mapping="swagger-ui555.html"/-->
   	<!-- mvc:resources location="classpath:/META-INF/resources/webjars/" mapping="/webjars/**"/-->
   	
</beans>